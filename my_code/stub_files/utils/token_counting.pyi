from _typeshed import Incomplete
from abc import ABC, abstractmethod
from camel.messages import OpenAIMessage
from camel.types import ModelType, UnifiedModelType

LOW_DETAIL_TOKENS: int
FIT_SQUARE_PIXELS: int
SHORTEST_SIDE_PIXELS: int
SQUARE_PIXELS: int
SQUARE_TOKENS: int
EXTRA_TOKENS: int
logger: Incomplete

def get_model_encoding(value_for_tiktoken: str): ...

class BaseTokenCounter(ABC):
    @abstractmethod
    def count_tokens_from_messages(self, messages: list[OpenAIMessage]) -> int: ...
    @abstractmethod
    def encode(self, text: str) -> list[int]: ...
    @abstractmethod
    def decode(self, token_ids: list[int]) -> str: ...

class OpenAITokenCounter(BaseTokenCounter):
    model: str
    tokens_per_message: int
    tokens_per_name: int
    encoding: Incomplete
    def __init__(self, model: UnifiedModelType) -> None: ...
    def count_tokens_from_messages(self, messages: list[OpenAIMessage]) -> int: ...
    def encode(self, text: str) -> list[int]: ...
    def decode(self, token_ids: list[int]) -> str: ...

class AnthropicTokenCounter(BaseTokenCounter):
    client: Incomplete
    model: Incomplete
    def __init__(self, model: str) -> None: ...
    def count_tokens_from_messages(self, messages: list[OpenAIMessage]) -> int: ...
    def encode(self, text: str) -> list[int]: ...
    def decode(self, token_ids: list[int]) -> str: ...

class LiteLLMTokenCounter(BaseTokenCounter):
    model_type: Incomplete
    def __init__(self, model_type: UnifiedModelType) -> None: ...
    @property
    def token_counter(self): ...
    @property
    def completion_cost(self): ...
    def count_tokens_from_messages(self, messages: list[OpenAIMessage]) -> int: ...
    def calculate_cost_from_response(self, response: dict) -> float: ...
    def encode(self, text: str) -> list[int]: ...
    def decode(self, token_ids: list[int]) -> str: ...

class MistralTokenCounter(BaseTokenCounter):
    model_type: Incomplete
    tokenizer: Incomplete
    def __init__(self, model_type: ModelType) -> None: ...
    def count_tokens_from_messages(self, messages: list[OpenAIMessage]) -> int: ...
    def encode(self, text: str) -> list[int]: ...
    def decode(self, token_ids: list[int]) -> str: ...
